# Foundations

Reference: https://maldus512.medium.com/bare-metal-programming-on-an-stm32f103-3a0f4e50ca29

Hardware Abstractions:
- Processor
   - Executes machine instructions generated by the compiler
   - Operates on data using registers and arithmetic/logic units
        - Registers:
            - Very fast
            - Hold values currently being operated on
            - Volatile
   - Controls program flow (branches, calls, interrupts)
- Memory
    - Array of bytes used by the processor where each byte has an address
    - Two categories:
        - RAM (Random Access Memory)
            - Working memory for running programs
            - Stores variables, stack, and heap
            - Fast; larger than registers
            - Volatile
        - FLASH
            - Non-volatile program and data storage
            - Stores firmware and persistent data
            - Slower than RAM; limited rewrites


Program Execution:
- The processor understands a fixed instruction set
- Instructions perform:
    - Arithmetic/logic operations
    - Reads/writes to registers and memory
- Memory roles:
    - Flash holds the program as a sequence of machine instructions
    - RAM holds the data that the program operates on
- Execution consists of repeatedly:
    - Fetching an instruction from memory
    - Executing it
    - Updating processor state and memory
- Key registers:
    - Program Counter (PC)
        - Holds the address of the current instruction in memory
        - Most instructions advance the PC to the next instruction
    - Stack Pointer (SP)
        - Holds the address of the current stack location in RAM
- Startup requirement:
    - For a program to begin execution, PC and SP must be initialized
        - Initialization cannot be performed by the program
        - Instead, it is handled by hardware

Reset and Program Startup (Cortex-M):
- Reset behavior:
    - On power-up/reset, the processor enters a Reset exception
    - Reset is a special exception that establishes the initial execution context
    - When reset is released, execution restarts from an address defined by hardware data structures
- Exceptions:
    - An event that changes the processor's execution context
    - Entering an exception updates the key registers, including PC and SP
- Vector table:
    - A fixed table in memory that defines how the processor starts and handles exceptions
    - On reset, the vector table is located at address 0x00000000
        - STM32 actually uses address aliasing, so 0x00000000 is aliased
            - Maps to flash (0x08000000) by default
            - System memory/SRAM depending on boot pins
    - Each entry contains an address used to initialize the execution state
        - Entry 0: Initial value of SP
        - Entry 1: Reset handler address (loaded into PC)
- Stack initialization:
    - The stack resides in RAM and grows toward lower addresses
    - SP is initialized to the highest valid RAM address (vector[0])
- Program Start:
    - After reset:
        - SP is loaded from vector table entry 0
        - PC is loaded from vector table entry 1
    - Execution begins at the reset handler
    - The reset handler handles system initialization and calling `main`

Memory Map and Boot-Time Address Aliasing (STM32F103)
- Flash memory
    - Non-volatile, writable memory used to store firmware and persistent data
    - On STM32F103, main Flash:
        - Base address: 0x08000000
        - Size: 128 KB
    - Compiled program binary is stored in Flash
- Boot memory aliasing
    - The Cortex-M architecture expects a vector table at address 0x00000000
    - On STM32, 0x00000000 is not a physical memory
    - Instead, it is aliased to boot to one of a few memory regions, depending on boot configuration
    - Default boot mode:
        - Flash memory at 0x08000000 is aliased to 0x00000000
        - The same Flash contents are visible at both addresses
    - This means placing the vector table at the beginning of Flash (0x08000000) automatically satisfies the CPU requirement that it appears at 0x00000000
    - No code ever writes directly to 0x00000000
    - The aliasing is handled entirely by the hardware

Linker Script and Binary Layout:
- Role of the linker:
    - The compiler generates object files
    - The linker:
        - Assigns absolute addresses
        - Lays out sections in memory
        - Produces the final binary image
    - Every build uses a linker script
- Linker script purpose:
    - Explicitly defines:
        - Where Flash and RAM exist
        - Where each section of the program is placed
    - Ensures that:
        - The vector table appears at the correct address
        - The SP is initialized correctly
- Memory regions:
    - A linker script defines named memory regions (e.g. FLASH, RAM)
    - Each region has:
        - An origin (base address)
        - A length (size)
        - Access permissions (read/write/execute)
    - Initial stack pointer:
        - A symbol is defined at top of RAM (ORIGIN(RAM) + LENGTH(RAM))
        - This value is placed as the first entry of the vector table
        - On reset, hardware loads this value into SP
    - Vector table construction:
        - The first entries of the binary correspond to:
            - Entry 0: Initial stack pointer
            - Entry 1: Reset handler address
        - The reset handler address must have bit 0 set to 1:
            - Indicates Thumb code (required by Cortex-M)
    - The binary placed in Flash begins with a valid vector table
    - Due to address aliasing, this vector table is visible at 0x00000000
    - The CPU boots correctly using these values

Compilation and Binary Generation
- Compilation overview:
    - Source code must be transformed into a binary image that can be placed into Flash memory
    - The process consists of:
        - Compilation (C source → object file)
        - Linking (object file → executable with fixed memory addresses)
        - Binary conversion (executable → raw binary)
- Toolchain:
    - arm-none-eabi-gcc
        - GCC cross-compiler targeting bare-metal ARM
        - No operating system or standard runtime assumed

Compilation (source → object file):
- Purpose:
    - Translate C source code into machine instructions
    - Does not assign final memory addresses
    - `arm-none-eabi-gcc -c -g -mcpu=cortex-m3 -mthumb main.c -o main.o`
        - -c
            - Compile only; do not link
        - -g
            - Include debug symbols
        - -mcpu=cortex-m3
            - Specify target architecture (Cortex-M3)
        - -mthumb
            - Generate Thumb instructions
            - Cortex-M processors execute Thumb-only code
        - main.o
            - Contains compiled instructions
            - Not yet placed in device memory

Linking (object file → ELF executable):
- Linking purpose:
    - Assign absolute memory addresses
    - Lay out sections according to the linker script
    - Produce an executable image matching the device memory map
    - `arm-none-eabi-gcc -nostdlib -nostartfiles -Wl,-Tmemory.ld main.o -o application.elf`
        - -Wl,
            - Pass options directly to the linker
        - -Tmemory.ld
            - Specify the custom linker script
            - Defines Flash/RAM layout and vector table placement
        - -nostdlib
            - Prevent linking against the C standard library
            - No malloc, free, or OS-provided functions
        - -nostartfiles
            - Prevent default startup files from being linked
            - Startup behavior is fully controlled by user-defined code
        - application.elf
            - Contains: Code, symbols, section metadata, debug information
            - Suitable for debugging
            - Not directly writable to Flash

Binary Conversion (ELF → raw binary):
- Purpose:
    - Convert the executable into a flat binary image
    - Remove metadata not understood by the MCU
- Command:
    - arm-none-eabi-objcopy -O binary application.elf application.bin
- Result:
    - application.bin
        - Raw binary image
        - Begins with the vector table
        - Can be written directly to Flash memory

